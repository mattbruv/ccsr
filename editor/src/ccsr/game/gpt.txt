/*
    Using the following types,
    And realizing what the functions I wrote are doing,
    write the remaining functions for parsing out the Item and Move information
    from the MapObjectData lingo object. I already did the message property.
    Do the item and move properties, writing a function for each which returns 
    their objects. 

    Then, write functions that take the objects (MapMetadata, MapObjectData),
    and then converts them back into Lingo Values.
*/


export enum LingoType {
    Object = "object",
    Array = "array",
    Identifier = "identifier",
    Number = "number",
    String = "string",
}

export type LingoValue = LingoObject | LingoArray | LingoLiteral;
export type LingoLiteral = LingoIdentifier | LingoString | LingoNumber;

export type LingoObject = {
    type: LingoType.Object;
    properties: LingoProperty[];
};

export type LingoArray = {
    type: LingoType.Array;
    children: LingoValue[];
};

export type LingoProperty = {
    key: LingoIdentifier;
    value: LingoValue;
};

export type LingoIdentifier = {
    type: LingoType.Identifier;
    value: string;
};

export type LingoNumber = {
    type: LingoType.Number;
    value: number;
};

export type LingoString = {
    type: LingoType.String;
    value: string;
};

export enum LingoTokenType {
    LeftBracket,
    RightBracket,
    Identifier,
    String,
    Number,
    Comma,
    Colon,
    WhiteSpace,
}

export type LingoToken = {
    type: LingoTokenType;
    value: string;
    index: number;
};


export type RecursivePartial<T> = {
    [P in keyof T]?: RecursivePartial<T[P]>;
}

export type MapData = RecursivePartial<MapMetadata> | RecursivePartial<MapObject>


export enum MapDataType {
    Metadata = "metadata",
    Object = "object",
}

/**
 * I don't think this is used in the actual game for anything
 */
export type MapMetadata = {
    dataType: MapDataType.Metadata;

    roomid: string;
    roomStatus: number;
};

/**
 * Represents some object in the game world
 */
export type MapObject = {
    dataType: MapDataType.Object;

    /** The name of the texture to use for this object */
    member: string;

    /** The type of game object */
    type: string;

    /** X, Y starting offset of this object within the map */
    location: MapObjectLocation;

    /** The width in pixels of this game object */
    width: number;

    /** The X-offset shift amount */
    WSHIFT: number;

    /** The height in piexels of this game object */
    height: number;

    /** The Y-offset shift amount */
    HSHIFT: number;

    /** Data related to this game object */
    data: MapObjectData;
};

export type MapObjectLocation = {
    x: number;
    y: number;
};

export type MapObjectData = {
    item: MapObjectItem;
    move: MapObjectMove;
    message: MapObjectMessage[];
};

export type MapObjectItem = {
    name: string;
    type: string;
    visi: MapObjectVisibility;
    COND: MapObjectCond;
};

export type MapObjectMove = {
    U: number;
    d: number;
    L: number;
    R: number;
    COND: number;
    TIMEA: number;
    TIMEB: number;
};

export type MapObjectMessage = {
    text: string;
    plrObj: string;
    plrAct: string;
};

export type MapObjectVisibility = {
    visiObj: string;
    visiAct: string;
    inviObj: string;
    inviAct: string;
};

export type MapObjectCond = string[];


export function lingoArrayToMapData(array: LingoArray): MapData[] {
    const mapData: MapData[] = []

    for (const child of array.children) {
        if (child.type === LingoType.Object) {
            // If it looks like a metadata object, parse that
            if (child.properties.some(x => x.key.value.includes("roomid")))
                mapData.push(lingoToMetadata(child))
            // Otherwise, it's a game object
            else
                mapData.push(lingoToMapObject(child))
        }
    }

    return mapData
}

function lingoToMetadata(object: LingoObject): RecursivePartial<MapMetadata> {
    const metadata: RecursivePartial<MapMetadata> = {
        dataType: MapDataType.Metadata
    }

    for (const property of object.properties) {
        const key = property.key.value;
        const value = property.value;

        if (key === "#roomid" && value.type == LingoType.String)
            metadata.roomid = value.value;
        if (key === "#roomStatus" && value.type === LingoType.Number)
            metadata.roomStatus = value.value;
    }

    return metadata;
}

function lingoObjectToMapObjectData(object: LingoObject): RecursivePartial<MapObjectData> {
    const data: RecursivePartial<MapObjectData> = {};

    for (const property of object.properties) {
        const key = property.key.value;
        const value = property.value;

        if (key === "#message" && value.type === LingoType.Array)
            data.message = lingoArrrayToMapObjectMessage(value);
    }

    return data;
}

function lingoArrrayToMapObjectMessage(array: LingoArray): RecursivePartial<MapObjectMessage>[] {
    const messages: RecursivePartial<MapObjectMessage>[] = []

    for (const child of array.children) {
        if (child.type !== LingoType.Object) continue;

        const message: RecursivePartial<MapObjectMessage> = {}

        for (const property of child.properties) {
            const key = property.key.value;
            const value = property.value;
            if (value.type !== LingoType.String) continue;
            if (key === "#text") message.text = value.value;
            if (key === "#plrObj") message.plrObj = value.value;
            if (key === "#plrAct") message.plrAct = value.value;
        }

        messages.push(message)
    }

    return messages;
}

function lingoArrayToLocation(array: LingoArray): RecursivePartial<MapObjectLocation> {
    const location: RecursivePartial<MapObjectLocation> = {};

    for (const [i, value] of array.children.entries()) {
        if (value.type === LingoType.Number) {
            if (i === 0) location.x = value.value;
            if (i === 1) location.y = value.value;
        }
    }

    return location;
}

function lingoToMapObject(object: LingoObject): RecursivePartial<MapObject> {

    const mapObject: RecursivePartial<MapObject> = {
        dataType: MapDataType.Object
    }

    for (const property of object.properties) {
        const key = property.key.value
        const value = property.value

        switch (value.type) {
            // Pull out all string values
            case LingoType.String: {
                switch (key) {
                    case "#member": mapObject.member = value.value; break;
                    case "#type": mapObject.type = value.value; break;
                }
                break;
            }
            case LingoType.Number: {
                switch (key) {
                    case "#width": mapObject.width = value.value; break;
                    case "#height": mapObject.height = value.value; break;
                    case "#WSHIFT": mapObject.WSHIFT = value.value; break;
                    case "#HSHIFT": mapObject.HSHIFT = value.value; break;
                }
                break;
            }
            case LingoType.Array: {
                switch (key) {
                    case "#location": mapObject.location = lingoArrayToLocation(value); break;
                }
                break;
            }
            case LingoType.Object: {
                switch (key) {
                    case "#data": mapObject.data = lingoObjectToMapObjectData(value); break;
                }
                break;
            }
        }
    }

    return mapObject;
}
